# IP 协议

文章来自于：https://github.com/xuanhao44/net-lab-2023

## 1 IP 协议概览

TODO

## 2 结合实验框架的实现

要完成三个函数：ip_in、ip_out、ip_fragment_out、checksum16。

- ip_in：处理一个收到的数据包
- checksum16：计算 16 位校验和
- ip_fragment_out：处理一个要发送的 ip 分片
- ip_out：处理一个要发送的 ip 数据包

### 2.1 ip_in

流程：

1. 如果数据包的长度小于 IP 头部长度，丢弃不处理。

2. 接下来做报头检测，检查内容至少包括：IP 头部的版本号是否为 IPv4，总长度字段小于或等于收到的包的长度等，如果不符合这些要求，则丢弃不处理。

3. 先把 IP 头部的头部校验和字段用其他变量保存起来，接着将该头部校验和字段置 0，然后调用 checksum16 函数来计算头部校验和，如果与 IP 头部的首部校验和字段不一致，丢弃不处理，如果一致，则再将该头部校验和字段恢复成原来的值。

4. 对比目的 IP 地址是否为本机的 IP 地址，如果不是，则丢弃不处理。

5. 如果接收到的数据包的长度大于 IP 头部的总长度字段，则说明该数据包有填充字段，可调用 buf_remove_padding() 函数去除填充字段。

6. 调用 buf_remove_header() 函数去掉 IP 报头。

7. 调用 net_in() 函数向上层传递数据包。如果是不能识别的协议类型，即调用 icmp_unreachable() 返回 ICMP 协议不可达信息。

### 2.2 checksum16

流程：

1. 把 data 看成是每 16 个 bit（即 2 个字节）组成一个数，相加（注意，16 位加法的结果可能会超过 16 位，因此加法结果需要用 32 位数来保存）。

2. 如果最后还剩 8 个 bit 值，也要相加这个 8bit 值。

3. 判断相加后 32bit 结果值的高 16 位是否为 0，如果不为 0，则将高 16 位和低 16 位相加，依次循环，直至高 16 位为 0 为止。

4. 将上述的和（低 16 位）取反，即得到校验和。

### 2.3 ip_fragment_out

流程：

1. 调用 buf_add_header() 增加 IP 数据报头部缓存空间。

2. 填写 IP 数据报头部字段。

3. 先把 IP 头部的首部校验和字段填 0，再调用 checksum16 函数计算校验和，然后把计算出来的校验和填入首部校验和字段。

4. 调用 arp_out 函数 () 将封装后的 IP 头部和数据发送出去。

### 2.4 ip_out

流程：

1. 首先检查从上层传递下来的数据报包长是否大于 IP 协议最大负载包长（1500 字节（MTU）减去 IP 首部长度）。

2. 如果超过 IP 协议最大负载包长，则需要分片发送。首先调用 buf_init() 初始化一个 ip_buf，将数据报包长截断，每个截断后的包长 = IP 协议最大负载包长（1500 字节 - IP 首部长度），调用 ip_fragment_out() 函数发送出去。如果截断后最后的一个分片小于或等于 IP 协议最大负载包长，调用 buf_init() 初始化一个 ip_buf，大小等于该分片大小，再调用 ip_fragment_out() 函数发送出去。注意，最后一个分片的 MF = 0。

3. 如果没有超过 IP 协议最大负载包长，则直接调用 ip_fragment_out() 函数发送出去。

## 3 实验结果和分析

结果如下：

## 4 实验中遇到的问题及解决方法

## 5 实验收获（和建议）
