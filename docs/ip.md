# IP 协议

文章来自于：https://github.com/xuanhao44/net-lab-2023

## 1 IP 协议概览

TODO

## 2 结合实验框架的实现

要完成三个函数：ip_in、ip_out、ip_fragment_out、checksum16。

- ip_in：处理一个收到的数据包
- checksum16：计算 16 位校验和
- ip_fragment_out：处理一个要发送的 ip 分片
- ip_out：处理一个要发送的 ip 数据包

在阅读指导书上的函数的流程之前先思考一下这些函数的大致功能，再去看流程：

![net_lab_ip_structure](https://typora-1304621073.cos.ap-guangzhou.myqcloud.com/typora/net_lab/net_lab_ip_structure.png)

注意到关于 in 和 out，发现每次都需要辨认很久（别笑我），发现还是有点需要注意的。显然不管是封装还是解封装，网络层这块总是从一层拿到数据，给另一层发数据，所以单纯用 in (进) 和 out (出) 去理解函数是不太对的。ip_out 就是指 IP 层 收到从 TCP 层来的包，处理后送到 MAC 层；ip_in 就是指 IP 层收到从 MAC 层来的包，处理后送到 TCP 层。

- ip_in：
  - 收到了哪里来的数据包？从数据链路层来的。发往哪里？发往传输层。
  - 怎么处理？显然是解封装的过程，即拆掉网络层的报头（从 MAC 层来的是已经去掉 MAC 报头的数据包）。
  - 流程中有哪些更多的内容：报头检测、IP 头部校检等等。
- ip_out：
  - 这个要发送的数据包从哪里来？从传输层来。发往哪里去？发往数据链路层。
  - 怎么处理：显然是需要封装上本层的 IP 报头的，但还需要注意的是需要将过大的数据包进行分片，所以可能会发出多个包。
  - 流程中有哪些更多的内容：只有一些很常规的数据包长度检测等。
### 2.1 ip_in

流程：

1. 如果数据包的长度小于 IP 头部长度，丢弃不处理。

2. 接下来做报头检测，检查内容至少包括：IP 头部的版本号是否为 IPv4，总长度字段小于或等于收到的包的长度等，如果不符合这些要求，则丢弃不处理。

3. 先把 IP 头部的头部校验和字段用其他变量保存起来，接着将该头部校验和字段置 0，然后调用 checksum16 函数来计算头部校验和，如果与 IP 头部的首部校验和字段不一致，丢弃不处理，如果一致，则再将该头部校验和字段恢复成原来的值。

4. 对比目的 IP 地址是否为本机的 IP 地址，如果不是，则丢弃不处理。

5. 如果接收到的数据包的长度大于 IP 头部的总长度字段，则说明该数据包有填充字段，可调用 buf_remove_padding() 函数去除填充字段。

6. 调用 buf_remove_header() 函数去掉 IP 报头。

7. 调用 net_in() 函数向上层传递数据包。如果是不能识别的协议类型，即调用 icmp_unreachable() 返回 ICMP 协议不可达信息。

### 2.2 checksum16

流程：

1. 把 data 看成是每 16 个 bit（即 2 个字节）组成一个数，相加（注意，16 位加法的结果可能会超过 16 位，因此加法结果需要用 32 位数来保存）。

2. 如果最后还剩 8 个 bit 值，也要相加这个 8bit 值。

3. 判断相加后 32bit 结果值的高 16 位是否为 0，如果不为 0，则将高 16 位和低 16 位相加，依次循环，直至高 16 位为 0 为止。

4. 将上述的和（低 16 位）取反，即得到校验和。

### 2.3 ip_fragment_out

流程：

1. 调用 buf_add_header() 增加 IP 数据报头部缓存空间。

2. 填写 IP 数据报头部字段。

3. 先把 IP 头部的首部校验和字段填 0，再调用 checksum16 函数计算校验和，然后把计算出来的校验和填入首部校验和字段。

4. 调用 arp_out 函数 () 将封装后的 IP 头部和数据发送出去。

### 2.4 ip_out

流程：

1. 首先检查从上层传递下来的数据报包长是否大于 IP 协议最大负载包长（1500 字节（MTU）减去 IP 首部长度）。

2. 如果超过 IP 协议最大负载包长，则需要分片发送。首先调用 buf_init() 初始化一个 ip_buf，将数据报包长截断，每个截断后的包长 = IP 协议最大负载包长（1500 字节 - IP 首部长度），调用 ip_fragment_out() 函数发送出去。如果截断后最后的一个分片小于或等于 IP 协议最大负载包长，调用 buf_init() 初始化一个 ip_buf，大小等于该分片大小，再调用 ip_fragment_out() 函数发送出去。注意，最后一个分片的 MF = 0。

3. 如果没有超过 IP 协议最大负载包长，则直接调用 ip_fragment_out() 函数发送出去。

## 3 实验结果和分析

结果如下：

## 4 实验中遇到的问题及解决方法

## 5 实验收获（和建议）
